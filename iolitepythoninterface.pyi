"""
Python stub file for iolitepythoninterface.h
Provides type hints and autocompletion for VS Code

To use this file, either add it to the workspace or create a 
pyrightconfig.json file in the workspace root with the following content:
{
    "extraPaths": [
        "/Users/[path to folder containing your stubfile]/folderName"
    ],
    "stubPath": "/Users/[path to folder containing your stubfile]/folderName",
    "pythonVersion": "3.8",
    "typeCheckingMode": "basic",
    "reportMissingImports": false
}

You may also want to create a virtual environment and install numpy to get the 
numpy type hints working correctly.

And finally, you may want to create a .vscode/settings.json file in the workspace root with the following content:
{
    "python.autoComplete.extraPaths": [
        "/Users/[path to folder containing your stubfile]/folderName"
    ]
}

This will enable autocompletion in VS Code.

To avoid import errors, in your script, add the following line:
from iolitepythoninterface import data, TimeSeriesDataType, SelectionGroupType, Result

but delete it before trying to run your script in iolite (as the data object is already available in iolite's Python environment).

Please send any feedback to support@iolite-software.com

"""

from typing import List, Dict, Any, Optional, Union, Tuple, overload
from datetime import datetime
import numpy as np
from enum import Enum


def formatNumberToSigFigs(number: float, sigFigs: int) -> str: ...


class TimeSeriesDataType(Enum):
    Input = 1
    Intermediate = 2
    Output = 4



class SelectionGroupType(Enum):
    Baseline = 1
    ReferenceMaterial = 2
    Sample = 4


class ProgressIndicator:
    def __init__(self, title: str) -> None: ...
    
    @property
    def progress(self) -> int: ...
    
    @progress.setter
    def progress(self, value: int) -> None: ...
    
    @property
    def message(self) -> str: ...
    
    @message.setter
    def message(self, value: str) -> None: ...


class TimeSeriesDataPyInterface:
    @property
    def name(self) -> str: ...
    
    @name.setter
    def name(self, value: str) -> None: ...
    
    def typeAsString(self) -> str: ...
    def type(self) -> TimeSeriesDataType: ...
    def data(self) -> np.ndarray: ...
    def setData(self, obj: np.ndarray) -> None: ...
    def time(self) -> np.ndarray: ...
    def setTime(self, obj: np.ndarray) -> None: ...
    def bounds(self) -> Tuple[float, float, float, float]: ...
    def hash(self) -> int: ...
    
    def properties(self) -> Dict[str, Any]: ...
    def property(self, name: str) -> Any: ...
    def setProperty(self, name: str, value: Any) -> None: ...
    def setProperties(self, properties: Dict[str, Any]) -> None: ...
    
    def dataForSelection(self, selection: 'SelectionPyInterface') -> np.ndarray: ...
    def timeForSelection(self, selection: 'SelectionPyInterface') -> np.ndarray: ...
    def selectionIndices(self, selection: 'SelectionPyInterface') -> np.ndarray: ...


class SelectionPyInterface:
    @property
    def name(self) -> str: ...
    
    @name.setter
    def name(self, value: str) -> None: ...
    
    @property
    def comment(self) -> str: ...
    
    @comment.setter
    def comment(self, value: str) -> None: ...
    
    @property
    def startTime(self) -> datetime: ...
    
    @startTime.setter
    def startTime(self, value: datetime) -> None: ...
    
    @property
    def endTime(self) -> datetime: ...
    
    @endTime.setter
    def endTime(self, value: datetime) -> None: ...
    
    @property
    def duration(self) -> float: ...
    
    @property
    def midTimestamp(self) -> float: ...
    
    @property
    def midDateTime(self) -> datetime: ...
    
    def group(self) -> 'SelectionGroupPyInterface': ...
    def setGroup(self, group: 'SelectionGroupPyInterface') -> None: ...
    
    def properties(self) -> Dict[str, Any]: ...
    def setProperties(self, properties: Dict[str, Any]) -> None: ...
    def property(self, name: str) -> Any: ...
    def setProperty(self, name: str, value: Any) -> None: ...
    
    def isLinked(self) -> bool: ...
    def hasLinks(self) -> bool: ...
    def linkedSelections(self) -> List[str]: ...
    def linkedStartTimestamp(self) -> float: ...
    def linkedStartDateTime(self) -> datetime: ...
    def linkedEndTimestamp(self) -> float: ...
    def linkedEndDateTime(self) -> datetime: ...
    def linkedMidTimestamp(self) -> float: ...
    def linkedMidDateTime(self) -> datetime: ...
    
    def errorStatus(self) -> str: ...
    def errorMessage(self) -> str: ...
    def isSame(self, other: 'SelectionPyInterface') -> bool: ...


class SelectionGroupPyInterface:
    @property
    def name(self) -> str: ...
    
    @name.setter
    def name(self, value: str) -> None: ...
    
    @property
    def count(self) -> int: ...
    
    @property
    def type(self) -> SelectionGroupType: ...
    
    @type.setter
    def type(self, value: SelectionGroupType) -> None: ...
    
    @property
    def splineType(self) -> str: ...
    
    @splineType.setter
    def splineType(self, value: str) -> None: ...
    
    def property(self, name: str) -> Any: ...
    def setProperty(self, name: str, value: Any) -> None: ...
    def setPropertyOnSelections(self, name: str, value: Any) -> None: ...
    def setPropertiesOnSelections(self, name: str, values: List[Any]) -> None: ...
    
    def selection(self, index: int) -> SelectionPyInterface: ...
    def selections(self) -> List[SelectionPyInterface]: ...
    def removeSelection(self, selection: SelectionPyInterface) -> None: ...
    def removeSelections(self, selections: List[SelectionPyInterface]) -> None: ...
    def stats(self, tsd: TimeSeriesDataPyInterface, outlierMethodString: str = "None", 
              avgTypeString: str = "Mean", uncertTypeString: str = "TwoSDabsolute") -> Dict[str, Any]: ...
    def indexOf(self, selection: SelectionPyInterface) -> int: ...


class FileMetadataPyInterface:
    def filePath(self) -> str: ...
    def fileName(self) -> str: ...
    def startTime(self) -> datetime: ...
    def endTime(self) -> datetime: ...
    def channelList(self) -> List[str]: ...
    def properties(self) -> Dict[str, Any]: ...
    def property(self, name: str) -> Any: ...
    def setProperty(self, name: str, value: Any) -> None: ...
    def removeProperty(self, propertyName: str) -> None: ...


class SampleMetadataPyInterface:
    def sampleName(self) -> str: ...
    def startTime(self) -> datetime: ...
    def endTime(self) -> datetime: ...
    def setStartTime(self, time: datetime) -> None: ...
    def setEndTime(self, time: datetime) -> None: ...
    def setSampleName(self, name: str) -> None: ...
    def properties(self) -> Dict[str, Any]: ...


class DRSPyInterface:
    def settings(self) -> Dict[str, Any]: ...
    def setSettings(self, settings: Dict[str, Any]) -> None: ...
    def setSetting(self, name: str, value: Any) -> None: ...
    def run(self) -> None: ...


class QAQCPyInterface:
    def settings(self) -> Dict[str, Any]: ...
    def setSettings(self, settings: Dict[str, Any]) -> None: ...
    def setSetting(self, name: str, value: Any) -> None: ...
    def run(self) -> None: ...
    def updateReport(self) -> None: ...
    def status(self) -> str: ...
    def messages(self) -> List[Dict[str, Any]]: ...
    def figures(self) -> List[Any]: ...  # QPixmap objects
    def html(self) -> str: ...


class Result:
    '''
    These enums are not actually available, but show the values that
    can be passed as strings to the methods.

    class Units(Enum):
        ppt = 0
        ppb = 1
        ppm = 2
        wtpc = 3
        wtpc_oxide = 4
        fg = 5
        ratio = 6
        Ma = 7
        ka = 8
        unknown = 9
    
    class UncertaintyType(Enum):
        AbsOneStdDev = 0
        AbsTwoStdDev = 1
        RelOneStdDev = 2
        RelTwoStdDev = 3
        AbsOneSE = 4
        AbsTwoSE = 5
        RelOneSE = 6
        RelTwoSE = 7
    
    class UncertaintyCombination(Enum):
        Basic = 0
        Propagated = 1
        RMinclusive = 2
    '''
    
    def value(self, r: Result) -> float: ...
    def valueInPPM(self, r: Result) -> float: ...
    def valueInUnits(self, r: Result, units: str) -> float: ...
    def setValue(self, r: Result, v: float) -> None: ...
    @overload
    def uncertainty(self, r: Result) -> float: ...
    @overload
    def uncertainty(self, r: Result, uncertComb: str, uncertType: str) -> float: ...
    def setUncertainty(self, r: Result, u: float) -> None: ...
    def setName(self, r: Result, name: str) -> None: ...
    def uncertaintyAs2SE(self, r: Result) -> float: ...
    def propagatedUncertainty(self, r: Result) -> float: ...
    def longerichLOD(self, r: Result) -> float: ...
    def howellLOD(self, r: Result) -> float: ...
    def pettkeLOD(self, r: Result) -> float: ...
    def numFinite(self, r: Result) -> int: ...
    def numOutliers(self, r: Result) -> int: ...
    def numMeasurements(self, r: Result) -> int: ...
    def sum(self, r: Result) -> float: ...
    def tidy(self, r: Result) -> str: ...
    def __str__(self, r: Result) -> str: ...
    def setUnits(self, r: Result, units: str) -> None: ...
    def units(self, r: Result) -> str: ...


class IolitePythonInterface:

    # Properties
    @property
    def elements(self) -> Dict[str, Any]: ...
    
    # TimeSeriesData methods
    def timeSeries(self, name: str) -> TimeSeriesDataPyInterface: ...
    def timeSeriesList(self, types: Optional[Union[int, TimeSeriesDataType]] = None, criteria: Optional[Dict[str, Any]] = None) -> List[TimeSeriesDataPyInterface]: ...
    def timeSeriesNames(self, types: Optional[Union[int, TimeSeriesDataType]] = None, criteria: Optional[Dict[str, Any]] = None) -> List[str]: ...
    def timeSeriesByMass(self, type: TimeSeriesDataType, mass: float, tol: float) -> TimeSeriesDataPyInterface: ...
    
    def createTimeSeries(self, name: str, type: TimeSeriesDataType, 
                        timeObj: Optional[np.ndarray] = None, 
                        dataObj: Optional[np.ndarray] = None, 
                        properties: Optional[Dict[str, Any]] = None) -> TimeSeriesDataPyInterface: ...
    def addDataToInput(self, channelName: str, inputTime: np.ndarray, inputData: np.ndarray, options: Dict[str, Any]) -> None: ...
    def addManyDataToInput(self, channelNames: List[str], inputTime: np.ndarray, inputData: np.ndarray, options: Dict[str, Any]) -> None: ...
    def removeTimeSeries(self, name: str) -> None: ...
    def createTimeSeriesFromMetadata(self, name: str, propertyName: str, 
                                   selections: Optional[List[SelectionPyInterface]] = None,
                                   defaultValue: float = float('nan'), 
                                   missingValue: float = float('nan')) -> TimeSeriesDataPyInterface: ...
    def createTimeSeriesFromResults(self, name: str, channel: TimeSeriesDataPyInterface,
                                  selections: Optional[List[SelectionPyInterface]] = None,
                                  defaultValue: float = float('nan')) -> TimeSeriesDataPyInterface: ...
    def createTimeSeriesFromSums(self, name: str, baseChannel: TimeSeriesDataPyInterface,
                               selections: List[SelectionPyInterface], interval: float,
                               gap: float = 0.0, overwrite: bool = False,
                               interpMethod: str = "None") -> TimeSeriesDataPyInterface: ...
    
    # SelectionGroup methods
    def selectionGroup(self, name: str) -> SelectionGroupPyInterface: ...
    def selectionGroupList(self, types: Optional[Union[int, SelectionGroupType]] = None, criteria: Optional[Dict[str, Any]] = None) -> List[SelectionGroupPyInterface]: ...
    def selectionGroupNames(self, types: Optional[Union[int, SelectionGroupType]] = None, criteria: Optional[Dict[str, Any]] = None) -> List[str]: ...
    def createSelectionGroup(self, name: str, type: SelectionGroupType, replace: bool = False) -> SelectionGroupPyInterface: ...
    def removeSelectionGroup(self, name: str) -> None: ...
    
    # Selection methods
    def createSelection(self, group: SelectionGroupPyInterface, startTime: datetime, endTime: datetime, name: str) -> SelectionPyInterface: ...
    def createSelections(self, group: SelectionGroupPyInterface, startTimes: List[datetime], 
                        endTimes: List[datetime], names: List[str]) -> List[SelectionPyInterface]: ...
    def checkSelections(self, groups: List[SelectionGroupPyInterface]) -> None: ...
    
    # Reference Material methods
    def referenceMaterialNames(self) -> List[str]: ...
    def referenceMaterialData(self, name: str) -> Dict[str, Any]: ...
    
    # Spline methods
    @overload
    def spline(self, groupName: str, channelName: str) -> TimeSeriesDataPyInterface: ...
    @overload
    def spline(self, x: np.ndarray, y: np.ndarray, w: np.ndarray, splineTypeName: str, sx: Optional[np.ndarray] = None) -> Any: ...
    def clearCachedSplines(self) -> None: ...
    def csaps(self, x: np.ndarray, y: np.ndarray, w: np.ndarray, xx: np.ndarray, p: float = -1) -> Any: ...
    
    # Result methods
    def updateResults(self) -> None: ...
    def result(self, selection: SelectionPyInterface, tsd: TimeSeriesDataPyInterface) -> Result: ...
    def groupResult(self, group: SelectionGroupPyInterface, tsd: TimeSeriesDataPyInterface) -> Result: ...
    def associatedResult(self, selection: SelectionPyInterface, resultName: str) -> Result: ...
    def associatedResultNames(self) -> List[str]: ...
    def registerAssociatedResult(self, name: str, obj: Any) -> None: ...
    def removeAssociatedResult(self, name: str) -> None: ...
    def clearCachedResults(self) -> None: ...
    
    # Metadata methods
    def importedFiles(self) -> List[FileMetadataPyInterface]: ...
    def importedLogs(self) -> List[FileMetadataPyInterface]: ...
    def laserLogSamples(self) -> List[SampleMetadataPyInterface]: ...
    def massSpecSamples(self) -> List[SampleMetadataPyInterface]: ...
    def createImportedFileMetadata(self, fileStartTime: Union[datetime, Any], fileEndTime: Union[datetime, Any],
                                 filePath: str, fileImportTime: Union[datetime, Any], 
                                 nPoints: int, channelNames: List[str]) -> FileMetadataPyInterface: ...
    def createFileSampleMetadata(self, sampleName: str, fileStartTime: Union[datetime, Any],
                               fileEndTime: Union[datetime, Any], filePath: str) -> SampleMetadataPyInterface: ...
    def createLaserLog(self, filePath: str, data: List[Any]) -> None: ...
    def setLaserLogData(self, filePath: str, attrName: str, value: float) -> None: ...
    def setLaserLogArray(self, filePath: str, attrName: str, array: np.ndarray) -> None: ...
    
    # Helper methods
    def propagateErrors(self, sglist: List[SelectionGroupPyInterface], tlist: List[TimeSeriesDataPyInterface],
                       nonDriftCorrectedChannel: TimeSeriesDataPyInterface, rmName: str) -> None: ...
    def pythonTypeString(self, obj: Any) -> str: ...
    def activeSelectionGroup(self) -> SelectionGroupPyInterface: ...
    def setActiveSelectionGroup(self, group: SelectionGroupPyInterface) -> None: ...
    def activeSelection(self) -> SelectionPyInterface: ...
    def setActiveSelection(self, selection: SelectionPyInterface) -> None: ...
    
    def clearIndexTime(self) -> None: ...
    def calculateTotalBeam(self) -> None: ...
    def compileDownhole(self, group: SelectionGroupPyInterface, channel: TimeSeriesDataPyInterface, bsMax: float = 60) -> Tuple[np.ndarray, np.ndarray]: ...
    
    def laserData(self, onIndexTime: bool = False) -> Dict[str, Any]: ...
    def emitDataChanged(self) -> None: ...
    def oxideToElementFactor(self, formula: str) -> float: ...
    def timeOffset(self, Atime: np.ndarray, Adata: np.ndarray, Btime: np.ndarray, Bdata: np.ndarray) -> float: ...
    
    def globalStartTime(self) -> datetime: ...
    def globalEndTime(self) -> datetime: ...
    def version(self) -> List[Any]: ...
    def splineOptions(self) -> List[str]: ...
    
    # Session methods
    def resetSession(self) -> None: ...
    def saveSession(self, filePath: str) -> None: ...
    def sessionFilePath(self) -> str: ...
    def sessionUUID(self) -> str: ...
    
    # Import methods
    def importData(self, filePath: str) -> bool: ...
    def importLog(self, filePath: str, syncChannelName: str = "TotalBeam") -> bool: ...
    def importISValues(self, filePath: str) -> Dict[str, Any]: ...
    
    # Frame methods
    @overload
    def frame(self, selections: List[SelectionPyInterface], selectionProperties: List[str],
             channels: List[TimeSeriesDataPyInterface], channelStats: List[str],
             channelProperties: Optional[List[str]] = None, 
             associatedResults: Optional[List[str]] = None) -> Any: ...
    @overload
    def frame(self, groups: List[SelectionGroupPyInterface], selectionProperties: List[str],
             channels: List[TimeSeriesDataPyInterface], channelStats: List[str],
             channelProperties: Optional[List[str]] = None,
             associatedResults: Optional[List[str]] = None) -> Any: ...
    
    # DRS methods
    def dataReductionSchemeNames(self) -> List[str]: ...
    def dataReductionScheme(self, name: str) -> DRSPyInterface: ...
    def createBeamSeconds(self, method: str, methodParams: Optional[Dict[str, Any]] = None) -> TimeSeriesDataPyInterface: ...
    
    # QAQC methods
    def qaqcNames(self) -> List[str]: ...
    def qaqc(self, name: str) -> QAQCPyInterface: ...
    
    # Export methods
    def exportFile(self, filePath: str, config: Dict[str, Any]) -> None: ...
    def exportFavorites(self) -> List[Any]: ...
    @overload
    def exportFavorite(self, i: int) -> Dict[str, Any]: ...
    @overload
    def exportFavorite(self, name: str) -> Dict[str, Any]: ...
    
    def addCitationToSession(self, text: str) -> None: ...
    def thingsToCite(self) -> List[str]: ...
    
    # HDF5 methods
    def getH5Array(self, filePath: str, dataPath: str) -> np.ndarray: ...
    def getH5Attr(self, filePath: str, target: str, attrName: str) -> Any: ...
    def getH5String(self, filePath: str, datasetPath: str) -> str: ...
    def createH5Group(self, filePath: str, groupPath: str) -> None: ...
    def createH5Array(self, filePath: str, dataPath: str, array: np.ndarray) -> None: ...
    def createH5Attr(self, filePath: str, target: str, attrName: str, value: Any) -> None: ...
    def createH5String(self, filePath: str, datasetPath: str, value: str) -> None: ...


class PyInterfaceDecorator:
    def new_ProgressIndicator(self, title: str) -> ProgressIndicator: ...


# Global instance (typical pattern for singleton interfaces)
data: IolitePythonInterface
